---
title: "Detecting Stress Using Wearables"
author: "Matty Pahren, Scott Heng On, Ethan Shen"
fontsize: 12pt
geometry: "left=1.3cm,right=1.3cm,top=1.3cm,bottom=1.3cm"
output: 
  pdf_document:
     latex_engine: xelatex
     number_sections: true
---

```{r, function checking for installed packages, include=FALSE}
# Validate that all necessary packaged have been downloaded, install otherwise or throw err package DNE
pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,repos = "http://cran.r-project.org", dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
```

```{r include=FALSE}
# Installing packages 
pkgTest("tidyverse")
pkgTest("knitr")
pkgTest("kableExtra")
pkgTest("caret")
pkgTest("randomForest")
pkgTest("MASS")
pkgTest("cvAUC")
pkgTest("car")
pkgTest("broom")
pkgTest("lme4")
pkgTest("cAIC4")
pkgTest("boot")
pkgTest("cvms")
```

```{r include=FALSE}
library(tidyverse)
library(knitr)
library(kableExtra)
library(caret)
library(randomForest)
library(MASS)
library(cvAUC)
library(car)
library(broom)
library(lme4)
library(cAIC4)
library(boot)
library(cvms)

knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
ggplot2::theme_set(new = theme_bw())
```

```{r load-data}

survey <- read_csv("survey.csv")
final_data <- readRDS("final_data.Rds")
sub_data <- readRDS("subj_df.Rds")

survey <- survey %>%
  rename(label = Label)

sub_data <- sub_data %>%
  rename(participant = Participant) %>% 
  mutate(`Dominant hand` = as.factor(`Dominant hand`),
         Gender = as.factor(Gender),
         `Height (cm)` = as.double(`Height (cm)`),
         `Weight (kg)` = as.double(`Weight (kg)`))

all_data <- final_data %>% 
  left_join(survey, by=c("participant", "label")) %>% 
  left_join(sub_data, by=c("participant")) %>% 
  filter(label != 1) %>% 
  mutate(label = case_when(
    label ==  2 ~ 1,
    label == 3 ~ 0
  )) %>% 
  mutate(label = as.factor(label)) %>% 
  mutate(participant = fct_relevel(participant,  c('S10', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S11', 'S13', 'S14', 'S15', 'S16', 'S17')))
```


```{r train-test}
set.seed(20200922)
idx = createDataPartition(all_data$label, p = 0.8, list = FALSE)
train = all_data[idx, ]
test = all_data[-idx, ]

train_control <- trainControl(method="repeatedcv", number = 5, savePredictions = T) # this is the cross validation
```

```{r metrics}
round_perc = function(x) {
  if (is.double(x)) {
    round(x*100, digits = 2) 
  }
}

calc_metrics = function(model, testing_data, folds) {
  list = list()
  acc_list = c()
  f1_list = c()
  AUC_list = c()
  
  # metrics for cross validated data
  for (i in 1:folds) {
    fold <- model$pred %>% pull(Resample) %>% unique() %>% .[i]
    
    fold_df <- model$pred %>% 
      filter(Resample == fold)
    
    # accuracy
    acc <- mean(fold_df$pred == fold_df$obs)
    acc_list[i] <- acc
    
    # F1 score
    precision <- posPredValue(fold_df$pred, fold_df$obs, positive="1")
    recall <- sensitivity(fold_df$pred, fold_df$obs, positive="1")
    F1 <- (2 * precision * recall) / (precision + recall)
    f1_list[i] <- F1
    
    # AUC
    AUC_list[i] <- cvAUC::AUC(fold_df$pred %>% as.double(), fold_df$obs %>% as.double())
  }
  
  acc_mean = acc_list %>% mean(na.rm=T) %>% round_perc()
  acc_sd = acc_list %>% sd(na.rm=T) %>% round_perc()
  f1_mean = f1_list %>% mean(na.rm=T) %>% round_perc()
  f1_sd = f1_list %>% sd(na.rm=T) %>% round_perc()
  AUC_mean = AUC_list %>% mean(na.rm=T) %>% round_perc()
  AUC_sd = AUC_list %>% sd(na.rm=T) %>% round_perc()
  
  # metrics for testing data
  pred <- predict(model, newdata = testing_data)
  test_acc <- mean(pred == testing_data %>% pull(label))
  
  cm <- confusionMatrix(as.factor(pred), testing_data$label)
  
  precision <- posPredValue(pred, testing_data$label, positive="1")
  recall <- sensitivity(pred, testing_data$label, positive="1")
  test_F1 <- (2 * precision * recall) / (precision + recall)
  
  test_AUC <-  AUC(pred %>% as.double(), testing_data$label %>% as.double())
  
  cv_df <- tibble(
    Accuracy = paste(acc_mean, "±", acc_sd),
    F1 = paste(f1_mean, "±", f1_sd),
    AUC = paste(AUC_mean, "±", AUC_sd)
  )
  
  test_df <- tibble(
    Accuracy = test_acc %>% round_perc(), 
    F1 = test_F1 %>% round_perc(),
    AUC = test_AUC %>% round_perc()
  )
  return(bind_cols(cv_df, test_df))
}

# returns accuracy/F1score/AUC if you run the model using the previous  code
```

```{r logistic-regression-wrist}
lr_model_final_wrist <- train(label ~ participant + sd_EDA_wrist + sd_ACC_wrist_mag + 
                                sd_heart_rate_variability_wrist_BVP + participant:sd_ACC_wrist_mag,
                              data = train, trControl = train_control, 
                              method = "glm",
                              family ="binomial") 
summary(lr_model_final_wrist$finalModel)
calc_metrics(lr_model_final_wrist, test, 5) %>%   kable(booktabs = T, 
        caption = "Parameters obtained with Model 1, with 95\\% Credible Intervals (CI)",
        col.names = c("Accuracy", "F1-Score", "AUC", "Accuracy", "F1-Score", "AUC"
        )) %>% 
  kable_styling(latex_options = c("hold_position")) %>%
add_header_above(c("Cross Validation Data" = 3, "Test Data" = 3))
vif(lr_model_final_wrist$finalModel) %>% kable()

# rf_model_final_wrist <- train(label ~ participant + sd_EDA_wrist + sd_ACC_wrist_mag + 
#                                 sd_heart_rate_variability_wrist_BVP + participant:sd_ACC_wrist_mag,
#                               data = train, trControl = train_control, 
#                               method = "rf") 
# summary(rf_model_final_wrist$finalModel)
# calc_metrics(rf_model_final_wrist, test)
# vif(rf_model_final_wrist$finalModel)
```

$$
Y_i \sim Bernoulli(\pi_i) \\
log(\frac{\pi_i}{1 - \pi_i}) = \beta_0 + \beta_1 \ \sigma^W_{EDA} + \beta_2 \ \sigma^W_{ACC} + \beta_3 \ \sigma^W_{HRV} +  \sum_{j=2}^{15}\beta_{4j} \ I(subject_i = j) + \\
\sum_{j=2}^{15} \beta_{5j}\ \sigma^W_{ACC} * I(subject_i = j)
$$

$i$ corresponds to each sample, and $Y_i$ indicates the corresponding state (1 = stress or 0 = amusement). $subject_i$ represents the unique subject ID that was assigned to each of the 15 participants. The reference level for $subject$ is Subject 10 (S10), who had the highest number of samples in the filtered dataset. The remaining levels $j \in (2, 3, \dots, 14, 15)$ correspond to S2, S3, S4, S5, S6, S7, S8, S9, S11, S13, S14, S15, S16 and S17 respectively. 


```{r full-logistic-model}
model <- glm(label ~ participant+ sd_EDA+ sd_EDA_wrist+ sd_Temp_chest+ sd_Temp_wrist+ min_Temp_wrist+ mean_EMG+min_EMG+ sd_inhale+ sd_exhale+ sd_breath+ min_breath+ max_breath+i_e_ratio+ mean_ACC_chest_mag+ sd_ACC_chest_mag+ mean_ACC_wrist_mag+ sd_ACC_wrist_mag+ sd_heart_rate_wrist_BVP+ sd_heart_rate_variability_wrist_BVP+ rms_heart_rate_variability_wrist_BVP+ sd_heart_rate_chest_ECG+ sd_heart_rate_variability_chest_ECG+ rms_heart_rate_variability_chest_ECG + 
      participant*sd_EDA_wrist + sd_heart_rate_variability_chest_ECG*participant + rms_heart_rate_variability_wrist_BVP*participant, # try different interactions 
    data = train, family = "binomial") %>%
  stepAIC(trace = FALSE)

# saved the model
# save(model, file = 'savedmodel')

# Model is pre-ran and save, can be loaded to save time- loading and calling 'model'
# load('savedmodel')
# model

# prediction
pred <- predict(model, test, type="response")
pred <- ifelse(pred > 0.5, 1, 0)
mean(pred == test$label)

target <- test$label

summary(model)

car::vif(model)%>% round(2) %>% kable() 

```

```{r full-logistic-model (diagnostics)}
#VIF values (measures multi-collinearity)
vif(model)

#Sensitivity Analysis
prediction <- as.factor(pred)
table <- tidy(table(tibble("target" = target,
                     "prediction" = prediction)))
plot_confusion_matrix(table, 
                      targets_col = "target", 
                      predictions_col = "prediction",
                      counts_col = "n")
```

```{r random-forests}
set.seed(20200922)
forest_data <- all_data %>% 
  subset(select = -c(PANAS_Angry, PANAS_Irritated, SSSQ_Committed, SSSQ_Succeed, SSSQ_Motivated, SSSQ_Reflected, SSSQ_Concerned, SSSQ_Worried, Condition, PANAS_Sad))
forest_data <- forest_data[1:(length(forest_data)-1)]

forest_data <- forest_data %>%
  mutate(participant = as.factor(participant),
         Age = as.numeric(Age),
         Hand = as.factor(`Dominant hand`),
         Gender = as.factor(Gender),
         Height = as.numeric(`Height (cm)`),
         Weight = as.numeric(`Weight (kg)`))

forest_data <- forest_data %>% 
  subset(select = -c(`Dominant hand`, `Height (cm)`, `Weight (kg)`))

#idx = createDataPartition(forest_data$label, p = 0.8, list = FALSE)
#train = forest_data[idx, ]
#test = forest_data[-idx, ]

#correlationMatrix <- cor(subset(forest_data, select = -c(Gender, Hand, participant, label)))
#highlyCorrelated <- findCorrelation(correlationMatrix, cutoff=0.5, verbose = FALSE)

require(caTools)
# full_rf <- randomForest(
#   label ~ .,
#   data=train
# )
# 
# round(importance(full_rf), 2)
# 
# pred = predict(full_rf, newdata=test)
# cm=table(test$label, pred)
# cm
# 
# select_rf <- randomForest(
#   label ~ participant + mean_EDA + sd_EDA + min_EDA + max_EDA + mean_EDA_wrist + sd_EDA_wrist + min_EDA_wrist + max_EDA_wrist + range_EDA_wrist + min_EMG + range_EMG + mean_Temp_chest + min_Temp_chest + max_Temp_chest + mean_Temp_wrist + min_Temp_wrist + max_Temp_wrist + mean_exhale + max_resp + max_breath + mean_chest_ACC_X +mean_chest_ACC_Y + mean_chest_ACC_Z + mean_chest_ACC_sum + sd_chest_ACC_X + sd_chest_ACC_Y + sd_chest_ACC_Z + sd_chest_ACC_sum + peak_chest_ACC_X + peak_chest_ACC_Y + peak_chest_ACC_Z + mean_ACC_chest_mag + sd_ACC_chest_mag + mean_wrist_ACC_X + mean_wrist_ACC_Y + mean_wrist_ACC_Z + mean_wrist_ACC_sum + sd_wrist_ACC_X + sd_wrist_ACC_Y + sd_wrist_ACC_Z + sd_wrist_ACC_sum + peak_wrist_ACC_X + peak_wrist_ACC_Y + peak_wrist_ACC_Z + sd_ACC_wrist_mag + PANAS_Active + PANAS_Distressed + PANAS_Interested + PANAS_Inspired + PANAS_Annoyed + PANAS_Strong + PANAS_Guilty + PANAS_Scared + PANAS_Hostile + PANAS_Excited + PANAS_Proud + PANAS_Irritable + PANAS_Enthusiastic + PANAS_Ashamed + PANAS_Alert + PANAS_Nervous + PANAS_Determined + PANAS_Attentive + PANAS_Jittery + PANAS_Afraid + PANAS_Stressed + PANAS_Frustrated + PANAS_Happy + STAI_At_Ease + STAI_Nervous + STAI_Jittery + STAI_Relaxed + STAI_Worried + STAI_Pleasant + SAM_Valence + SAM_Arousal + Age + Gender+ Height + Weight, data=train)
# round(importance(select_rf), 2)
# 
# pred = predict(select_rf, newdata=test)
# cm=table(test$label, pred)
# cm
# 
# sparse_rf <- randomForest(
#   label ~ PANAS_Stressed, data=train)
# round(importance(sparse_rf), 2)
# pred = predict(sparse_rf, newdata=test)
# cm=table(test$label, pred)
# cm
# 
# all_no_survey_rf <- randomForest(
#   label ~ participant + mean_EDA + sd_EDA + min_EDA + max_EDA + range_EDA + mean_EDA_wrist + sd_EDA_wrist + min_EDA_wrist + max_EDA_wrist + range_EDA_wrist + mean_EMG + sd_EMG + max_EMG + min_EMG + range_EMG + mean_Temp_chest + sd_Temp_chest + min_Temp_chest + max_Temp_chest + range_Temp_chest + mean_Temp_wrist + sd_Temp_wrist + min_Temp_wrist + max_Temp_wrist + range_Temp_wrist + mean_inhale + sd_inhale + mean_exhale + sd_exhale + min_resp + max_resp + range_resp + mean_breath + sd_breath + min_breath + max_breath + range_breath + mean_chest_ACC_X + mean_chest_ACC_Y + mean_chest_ACC_Z + mean_chest_ACC_sum + sd_chest_ACC_X + sd_chest_ACC_Y + sd_chest_ACC_Z + sd_chest_ACC_sum + peak_chest_ACC_X + peak_chest_ACC_Y + peak_chest_ACC_Z + mean_ACC_chest_mag + sd_ACC_chest_mag + mean_wrist_ACC_X + mean_wrist_ACC_Y + mean_wrist_ACC_Z + mean_wrist_ACC_sum + sd_wrist_ACC_X + sd_wrist_ACC_Y + sd_wrist_ACC_Z + sd_wrist_ACC_sum + peak_wrist_ACC_X + peak_wrist_ACC_Y + peak_wrist_ACC_Z + sd_ACC_wrist_mag + mean_heart_rate_wrist_BVP + sd_heart_rate_wrist_BVP + mean_heart_rate_variability_wrist_BVP + sd_heart_rate_variability_wrist_BVP + rms_heart_rate_variability_wrist_BVP +  mean_heart_rate_chest_ECG + sd_heart_rate_chest_ECG + mean_heart_rate_variability_chest_ECG + sd_heart_rate_variability_chest_ECG + rms_heart_rate_variability_chest_ECG + i_e_ratio + Age + Gender+ Height + Hand + Weight, data=train)
# round(importance(all_no_survey_rf), 2)
# 
# pred = predict(all_no_survey_rf, newdata=test)
# cm=table(test$label, pred)
# cm

sparse_no_survey_rf <- randomForest(
  label ~ participant +  max_EDA_wrist + sd_ACC_chest_mag, data=train)
round(importance(sparse_no_survey_rf), 2)

pred = predict(sparse_no_survey_rf, newdata=test)
cm=table(test$label, pred)
cm

misclass_rate = (64+27)/(4339+64+27+7888)
misclass_rate

print(sparse_no_survey_rf)

wrist_rf <- randomForest(
  label ~ participant + min_EDA_wrist + max_EDA_wrist + range_EDA_wrist + sd_wrist_ACC_Z, data=train)
round(importance(wrist_rf), 2)

pred = predict(wrist_rf, newdata=test)
cm=table(test$label, pred)
cm

misclass_rate = (5+20)/(4398+5+20+7895)
misclass_rate

```

```{r cv-random-forest, eval=FALSE}
newidx = createDataPartition(train$label, p = 0.01, list = FALSE)
newtrain = train[newidx, ]
#test = forest_data[-idx, ]
sparse_no_survey_rf <- train(
  label ~ participant +  max_EDA_wrist + sd_ACC_chest_mag, data=newtrain,
  trControl = train_control, method = "rf"
)

calc_metrics(sparse_no_survey_rf, test)


wrist_rf <- train(
  label ~ participant + min_EDA_wrist + max_EDA_wrist + range_EDA_wrist + sd_wrist_ACC_Z, data=newtrain,
  trControl = train_control, method = "rf")

calc_metrics(wrist_rf, test)

```

```{r Hierarchal Model}
# Fixed Effects (survey & subdata variables)
survey_var<- paste(colnames(survey))
sub_var <- paste(colnames(sub_data))
fixed_var <- c(survey_var, sub_var)

fixed_var <- fixed_var[-c(2,37:42)] # removed missing SSSQ variables because of NA

# Random Effects (wearable variables)
wearable_var <- paste ("(1|",colnames(final_data)[-c(1,2)], ")")

# Formula
mlm_formula <- as.formula(paste("as.numeric(label) ~ participant + ", paste(wearable_var[c(9,50)], collapse= "+")))

mlm <- lmer(mlm_formula, data = train, REML=FALSE,control = lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.rankZ = "ignore", check.nobs.vs.nRE="ignore", optimizer ="Nelder_Mead", ))
summary(mlm)
stepAIC(mlm, direction = "backward", trace = TRUE, data = train)
```



# Introduction 

Affect recognition seeks to detect a person’s affective state. One of these states is stress, and long-term stress is known to have severe implications on human health and well-being. This study uses the Wearable Stress and Affect Detection (WESAD) dataset, which was introduced in Schmidt et al. [[1]][Bibliography], and ___ (main results of the modeling or something). 

In conducting this analysis, we aim to determine whether sensor data are useful in predicting stress, and if so, which predictors are most significant when discriminating between stress and amusement. Furthermore, we seek to understand which types of sensor data are most useful in predicting stress, alone or in combination, and to determine if stress can be detected only using the wrist-worn wearable, which is more convenient to wear than a chest-worn device. Finally, we quantify the heterogeneity across individuals in their responses to stress by _____. 

# Literature Review 

# Data 

The WESAD dataset contains physiological and motion data on 15 test subjects. For this analysis, we used the raw data included in the provided pickle files, which synchronised the high resolution data from the chest-worn wearables and the lower resolution data from the wrist-worn wearables. The chest data, which were all recorded at 700 Hz, includes electrocardiography (ECG) data in mV, electrodermal activity (EDA) in microseconds, electromyography (EMG) data in mV, skin temperature (TEMP) in °C, displacement of the thorax for males and the abdomen for females induced by inhaling or exhaling (RESP) as a percentage, and 3-axis accelerometer (ACC) data in g - the acceleration of gravity. The wrist data includes blood volume pulse (BVP) data, ACC data in 1/64g, EDA in microseconds, and TEMP in °C; BVP was sampled at 64 Hz, ACC was sampled at 32 Hz, and EDA and TEMP were sampled at 4 Hz. 

Each sample also contains a label from 0-7 corresponding to the study protocol condition, where 2 refers to stress, and 3 refers to amusement. 1 is the baseline and 4 refers to meditation, but since we are mainly interested in discriminating between stress and amusement, we excluded these categories from our analysis. Samples labeled as 0, 5, 6, 7 should be ignored, and were also excluded from our analysis. 

The dataset also included information about each of the subject’s personal characteristics, such as their height and weight, as well as their responses to questionnaires, such as PANAS [[2]][Bibliography].

# Methodology

## Feature Engineering

The brain takes .9 milliseconds to shift a body into a full stress response, which suggests that these data should be sampled at approximately 1111 Hz to properly identify a state of stress. However, the highest-resolution data is sampled at 700 Hz, which suggests that these data are not granular enough to fully capture a shift to stress. Thus, with computational cost in mind, we downsampled our data to 4Hz. We assigned a unique ID to each of the 15 subjects, and also added their personal characteristics. Since we are primarily interested in differentiating between stress and amusement, we only kept samples that were labeled 2 (stress) or 3 (amusement). We then relabeled amusement as 0 and stress as 1.

Next, we calculated features for the different modalities, which are displayed in Table #.  Segmentation of the physiological signals was done using a sliding window, with a window shift of 0.25 seconds. The ACC and physiological features were both calculated with a 5 second window size [[3]][Bibliography] [[4]][Bibliography]. 

```{r}
features_tbl <- data.frame(
  Metric = c(rep("Chest ACC", 1), rep("Chest ECG", 1), rep("Chest EDA",2), rep("Chest EMG",2), "Chest Resp", "Chest Temp", 
             "Wrist ACC", "Wrist BVP", "Wrist EDA", "Wrist Temp"),
  
  Features = linebreak(c("Mean ($\\mu^C_{ACC}$), SD ($\\sigma^C_{ACC}$)", 
               "Mean ($\\mu^C_{ECG}$), SD ($\\sigma^C_{ECG}$), Mean HRV ($\\mu^C_{HRV}$), SD HRV ($\\sigma^C_{HRV}$)", 
               "Mean ($\\mu^C_{EDA}$), SD ($\\sigma^C_{EDA}$), Min ($Min^C_{EDA}$)", 
               "Max ($Max^C_{EDA}$), Range ($Range^C_{EDA}$)", 
               "Mean ($\\mu^C_{EMG}$), SD ($\\sigma^C_{EMG}$), Min ($Min^C_{EMG}$)", 
               "Max ($Max^C_{EMG}$), Range ($Range^C_{EMG}$)", 
               "Mean Std Deviation", 
               "Mean ($\\mu^C_{T}$), SD ($\\sigma^C_{T}$), Min ($Min^C_{T}$), Max ($Max^C_{T}$), Range ($Range^C_{T}$)", 
               "Mean ($\\mu^W_{ACC}$), SD ($\\sigma^W_{ACC}$)", 
               "Mean Std Deviation Heart Rate Variability", 
               "Mean ($\\mu^W_{EDA}$), SD ($\\sigma^W_{EDA}$), Min ($Min^W_{EDA}$), Max ($Max^W_{EDA}$), Range ($Range^C_{EDA}$)", 
               "Mean ($\\mu^W_{T}$), SD ($\\sigma^W_{T}$), Min ($Min^W_{T}$), Max ($Max^W_{T}$), Range ($Range^W_{T}$)"))
)

features_tbl %>% 
  kable("latex", escape=F, booktabs = T,
        caption = "Summary of Sensor Data Categories, with the Extracted Predictors and Respective Symbols",) %>%
  kable_styling(latex_options = c("hold_position")) %>% 
  group_rows(index = c("Chest Sensor Data" = 8, "Wrist Sensor Data" = 4)) %>%
  #column_spec(1, bold=T) %>%
  collapse_rows(columns = 1, latex_hline = "major") %>% 
  row_spec(0, bold = TRUE) %>% 
  column_spec(column = c(2), latex_column_spec = "c")
```


## Model Selection 

# Results 

## Testing MSE or something 

## Model Diagnostics 

## Sensitivity Analysis 

```{r}
#sensitivity analysis with 10 folds --> pretty much the same 

lr_model_final_wrist10_folds <- train(label ~ participant + sd_EDA_wrist + sd_ACC_wrist_mag + 
                                sd_heart_rate_variability_wrist_BVP + participant:sd_ACC_wrist_mag,
                              data = train, trControl = trainControl(method="repeatedcv", number = 10, savePredictions = T), 
                              method = "glm",
                              family ="binomial") 


calc_metrics(lr_model_final_wrist10_folds, test, 10) %>%   kable(booktabs = T, 
        caption = "Parameters obtained with Model 1, with 95\\% Credible Intervals (CI)",
        col.names = c("Accuracy", "F1-Score", "AUC", "Accuracy", "F1-Score", "AUC"
        )) %>% 
  kable_styling(latex_options = c("hold_position")) %>%
add_header_above(c("Cross Validation Data" = 3, "Test Data" = 3))
```


# Discussion

# Conclusion 

# Appendix 

## Bibliography

1. P. Schmidt et al. (2018). Introducing WESAD, a Multimodal Dataset for Wearable Stress and Affect Detection. Proceedings of the 2018 on International Conference on Multimodal Interaction - ICMI 18.

2. D. Watson, L. A. Clark and A. Tellegen. (1988). Development and validation of brief measures of positive and negative affect: the PANAS scales. Journal of Personality and Social Psychology, 54, 6, 1063.

3. M. Arif and A. Kattan. (2015). Physical Activities Monitoring Using Wearable Acceleration Sensors Attached to the Body. PLoS ONE 10, 7.

4. G. Uy et al. (2013). Correlation of Stress Inducers and Physiological Signals with Continuous Stress Annotations. WCTP 2012, PICT 7, pp. 178–183.